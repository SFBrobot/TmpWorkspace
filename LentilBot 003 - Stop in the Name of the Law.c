#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  lDown,          sensorDigitalOut)
#pragma config(Sensor, dgtl2,  rDown,          sensorDigitalOut)
#pragma config(Sensor, dgtl3,  rRelease,       sensorDigitalOut)
#pragma config(Sensor, dgtl4,  lRelease,       sensorDigitalOut)
#pragma config(Sensor, I2C_1,  lDriveEnc,      sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rDriveEnc,      sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  flyEnc,         sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           lift,          tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           brDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port3,           mrDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           blDrive,       tmotorVex393HighSpeed_MC29, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port5,           mlDrive,       tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port6,           frDrive,       tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port7,           flDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port8,           rFly,         tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port9,           lFly,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          intake,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//NB: *Release pistons are inverted but *Down pistons ARE NOT INVERTED.

#include "rkUtil003.h"

#include "rkLogic/dlatch001.h"

#include "rkControl/base002.h"
#include "rkControl/diff003.h"
#include "rkControl/tbh006.h"
#include "rkControl/tbhController002.h"

#define RKCOMP_LCD
//#define RKCOMP_DEBUG //Comment to disable debug mode

#define RKCOMP_DEBUG_MENU_COND vexRT[Btn8R]
#define RKCOMP_DEBUG_DISABLE_COND vexRT[Btn8U]
#define RKCOMP_DEBUG_AUTON_COND vexRT[Btn8L]
#define RKCOMP_DEBUG_DRIVER_COND vexRT[Btn8D]
#define RKCOMP_DEBUG_RESTART_COND vexRT[Btn6U]

#include "rkCompetition003a.h"

float flyLRPwr = 900, flySRPwr = 500;
ADiff flyDiff, fly2Diff;
Tbh flyTbh, fly2Tbh;
TbhController flyCtl;

const float autonFlyPwr = 800,
	velThresh = 50,
	accelThresh = 200;

task lcd() {
	while (true) {
		clearLCD();

		displayLCDCenteredString(0, "Lentilbot");
		displayLCDCenteredString(1, "4800Circles");

		wait1Msec(50);
	}
}

void setFly(word value) {
	motor[lFly] = motor[rFly] = value;
}

void setDown(word value) {
	SensorValue[lDown] = SensorValue[rDown] = value;
}

void setRelease(word value) {
	SensorValue[lRelease] = SensorValue[rRelease] = value;
}

bool canRetract = true;
task retractPneumatics() {
	canRetract = false;

	setDown(1);

	wait1Msec(200);

	setRelease(1);

	wait1Msec(1000);

	setDown(0);

	canRetract = true;
}

void startFlyTbh(bool doUseController) {
	resetTbh(&flyTbh, 0);

	resetDiff(&flyDiff, 0);
	resetDiff(&fly2Diff, 0);

	if (doUseController) updateTbhController(&flyCtl, 0);
	else setTbhDoRun(&flyTbh, true);

	SensorValue[flyEnc] = 0;
}

void stopCtls() {
	setTbhDoRun(&flyTbh, false);

	stopCtlLoop();
}

void init() {
	ctlLoopInterval = 50;

	initTbh(&flyTbh, 5, .5, 0, 127, true);

	initTbhController(&flyCtl, &flyTbh, false);

	setRelease(0);
	setDown(0);
}

void updateCtl(float dt) {
	updateDiff(&flyDiff, SensorValue[flyEnc], dt);
	updateDiff(&fly2Diff, flyDiff.out, dt);

	if (flyTbh.doUpdate)
		motor[lFly] = motor[rFly] = updateTbh(&flyTbh, flyDiff.out, fly2Diff.out, dt);
}

task auton() {
	const float recoilThresh = 75,
		recoil2Thresh = 300;

	startFlyTbh(false);
	startCtlLoop();

	setTbh(&flyTbh, autonFlyPwr);

	motor[blDrive] = motor[mlDrive] = motor[flDrive] =
		motor[brDrive] = motor[mrDrive] = motor[frDrive] = 127;

	wait1Msec(3000);

	motor[blDrive] = motor[mlDrive] = motor[flDrive] =
		motor[brDrive] = motor[mrDrive] = motor[frDrive] = 0;

	block(!(isTbhInThresh(&flyTbh, velThresh) &&
		isTbhDerivInThresh(&flyTbh, accelThresh)));

	while (true) {
		motor[intake] = motor[lift] = 80;

		block(isTbhInThresh(&flyTbh, recoilThresh) &&
			isTbhDerivInThresh(&flyTbh, accelThresh));

		motor[intake] = motor[lift] = 0;

		block(!(isTbhInThresh(&flyTbh, velThresh) &&
			isTbhDerivInThresh(&flyTbh, accelThresh)));

		wait1Msec(20);
	}
}

void endAuton() {
	stopCtls();
}

task userOp() {
	startFlyTbh(true);
	startCtlLoop();

	DLatch flyLRLatch, flySRLatch, arcadeLatch, cutLatch;

	word driveA, driveB,
		flyDir = 0;

	bool doArcade = true, doCut = false;

	const float cutFac = 3;

#define driveX driveA
#define driveY driveB
#define driveL driveA
#define driveR driveB

	resetDLatch(&flyLRLatch, 0);
	resetDLatch(&flySRLatch, 0);
	resetDLatch(&arcadeLatch, 0);
	resetDLatch(&cutLatch, 0);

	while (true) {
		if (risingEdge(&arcadeLatch, vexRT[Btn8D]))
			doArcade = !doArcade;

		if (risingEdge(&cutLatch, vexRT[Btn8U]))
			doCut = !doCut;

		if (doArcade) {
			driveX = vexRT[ChLX];
			driveY = vexRT[ChLY];

			if (doCut) {
				driveX /= cutFac;
				driveY /= cutFac;
			}

			motor[blDrive] = motor[mlDrive] = motor[flDrive] =
				arcadeLeft(driveX, driveY);

			motor[brDrive] = motor[mrDrive] = motor[frDrive] =
				arcadeRight(driveX, driveY);
		}
		else {
			driveL = vexRT[ChLY];
			driveR = vexRT[ChRY];

			if (doCut) {
				driveL /= cutFac;
				driveR /= cutFac;
			}

			motor[blDrive] = motor[mlDrive] = motor[flDrive] =
				tankLeft(driveL, driveR);

			motor[brDrive] = motor[mrDrive] = motor[frDrive] =
				tankRight(driveL, driveR);
		}

		if (risingEdge(&flyLRLatch, vexRT[Btn5U]))
			flyDir = flyDir == 1 ? 0 : 1;

		if (risingEdge(&flySRLatch, vexRT[Btn5D]))
			flyDir = flyDir == 2 ? 0 : 2;

		switch (flyDir) {
			case 1: updateTbhController(&flyCtl, flyLRPwr); break;
			case 2: updateTbhController(&flyCtl, flySRPwr); break;
			default: updateTbhController(&flyCtl, 0); break;
		}

		motor[intake] = motor[lift] =
			joyDigi2(Btn6U, 127, Btn6D, -127);

		if (canRetract && vexRT[Btn7U] && vexRT[Btn8U]) {
			startTask(retractPneumatics);
		}

		EndTimeSlice();
	}

#undef driveX
#undef driveY
#undef driveL
#undef driveR
}

void endUserOp() {
	stopCtls();
}
