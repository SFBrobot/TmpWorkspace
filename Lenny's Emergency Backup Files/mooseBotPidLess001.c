#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  redLed,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  yellowLed,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  greenLed,       sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           elevator,      tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           frWheel,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           flWheel,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           brWheel,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           blWheel,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           trFly,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           tlFly,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           brFly,         tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port9,           blFly,         tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          roller,        tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#include "rkUtil002.h"
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

int flyTarget = 930;
const int flyThresh = 100;
int lEnc = 0;
int lEncLast = 0;
int rEnc = 0;
int rEncLast = 0;
int lVel[10];
int rVel[10];
int lVelAvg = 0;
int rVelAvg = 0;
int velAvg = 0;
const int lRFlyThresh = 25;
float batt = 0;
string battStr;

void setFlywheel(int power) {
	motor[blFly] = motor[brFly] = motor[tlFly] = motor[trFly] = power;
}

void setLeds(char id) {
  switch (id) {
  	case 0:
  		SensorValue[redLed] = 1;
  		SensorValue[yellowLed] = 0;
  		SensorValue[greenLed] = 0;
  	break;
  	case 1:
  		SensorValue[redLed] = 0;
  		SensorValue[yellowLed] = 1;
  		SensorValue[greenLed] = 0;
  	break;
  	case 2:
  		SensorValue[redLed] = 0;
  		SensorValue[yellowLed] = 0;
  		SensorValue[greenLed] = 1;
  	break;
  	default:
  		SensorValue[redLed] = 0;
  		SensorValue[yellowLed] = 0;
  		SensorValue[greenLed] = 0;
  	break;
  }
}


task rpmCalc() {
	while(true) {
		for(int i; i < 9; i++) {
			lEnc = nMotorEncoder[blFly];
			lVel[i] = lEnc - lEncLast;
			lVelAvg += lVel[i];
			lEncLast = lEnc;
			rEnc = nMotorEncoder[brFly];
			rVel[i] = rEnc - rEncLast;
			rVelAvg += rVel[i];
			rEncLast = rEnc;
			wait1Msec(20);
		}
		lVelAvg = lVelAvg / 10;
		rVelAvg = rVelAvg / 10;
		velAvg = (lVelAvg + rVelAvg) / 2;
		EndTimeSlice(); //I'm not sure if the wait1Msec in the for loop will always release the CPU
	}
}

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = false;
	nMotorEncoder[blFly] = nMotorEncoder[brFly] = 0;
	for(int i; i < 9; i++) {
		lVel[i] = rVel[i] = 0;
	}
	bLCDBacklight = true;
	clearLCDLine(0);
	clearLCDLine(1);
	batt = nAvgBatteryLevel / 1000.0; //The decimal is necessary because operators return values as simple as the most complex number
	sprintf(battStr, "%1.2f", batt);
	displayLCDCenteredString(0, "Battery:");
	displayLCDCenteredString(1, battStr);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	startTask(rpmCalc);
	while(true) {
		if(abs(flyTarget - velAvg) > flyThresh + 50 || abs(lVelAvg - rVelAvg) > lRFlyThresh) {
			setLeds(0);
		}
		else if(abs(flyTarget - velAvg) < flyThresh + 50 && abs(flyTarget - velAvg) > flyThresh) {
			setLeds(1);
		}
		else {
				setLeds(2);
		}
		if(abs(lVelAvg - rVelAvg) > lRFlyThresh) {
			if(lVelAvg > rVelAvg) {
				motor[blFly] = motor[tlFly] = 95;
				motor[brFly] = motor[trFly] = 127;
			}
			else {
				motor[brFly] = motor[trFly] = 95;
				motor[blFly] = motor[tlFly] = 127;
			}
		}
		else if(flyTarget - velAvg > flyThresh) {
			setFlywheel(127);
		}
		else if(velAvg - flyTarget > flyThresh) {
			setFlywheel(63);
		}
		else {
			setFlywheel(79);
			motor[elevator] = 127;

		}
		wait1Msec(20);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	word button5U2Last,
		button5D2Last;

	// User control code here, inside the loop

	while (true)
	{
		arcade4(vexRT[Ch1], vexRT[Ch3], flWheel, blWheel, frWheel, brWheel);
		joyDigiMtr2(roller, vexRT[Btn6U], 127, vexRT[btn6D], -127);
		setMotor(elevator, vexRT[Ch2Xmtr2]);
		if(vexRT[Btn5UXmtr2] && !button5U2Last) {
			flyTarget += 5;
		}
		else if(vexRT[Btn5DXmtr2] && !button5D2Last) {
			flyTarget -= 5;
		}
		if(vexRT[Btn5U]) {
			if(abs(flyTarget - velAvg) > flyThresh + 50 || abs(lVelAvg - rVelAvg) > lRFlyThresh) {
				setLeds(0);
			}
			else if(abs(flyTarget - velAvg) < flyThresh + 50 && abs(flyTarget - velAvg) > flyThresh) {
				setLeds(1);
			}
			else {
				setLeds(2);
			}
			if(abs(lVelAvg - rVelAvg) > lRFlyThresh) {
				if(lVelAvg > rVelAvg) {
					motor[blFly] = motor[tlFly] = 95;
					motor[brFly] = motor[trFly] = 127;
				}
				else {
					motor[brFly] = motor[trFly] = 95;
					motor[blFly] = motor[tlFly] = 127;
				}
			}
			else if(flyTarget - velAvg > flyThresh) {
				setFlywheel(127);
			}
			else if(velAvg - flyTarget > flyThresh) {
				setFlywheel(63);
			}
			else {
				setFlywheel(79);
			}
		}
		else if(vexRT[Btn5D] && velAvg <= 50) {
			setFlywheel(-31);
		}
		else {
			setFlywheel(0);
			setLeds(3);
		}
		button5U2Last = vexRT[Btn5UXmtr2];
		button5D2Last = vexRT[Btn5DXmtr2];
		wait1Msec(20);
	}
}
