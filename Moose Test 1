#pragma config(Sensor, dgtl1,  flyEnc,         sensorQuadEncoder)
#pragma config(Motor,  port1,           roller,        tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           lDrive,        tmotorVex393TurboSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           lFly1,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           lFly2,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           lFly3,         tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           rFly1,         tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           rFly2,         tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           rFly3,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rDrive,        tmotorVex393TurboSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port10,          lift,          tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define RX vexRT[Ch1]
#define RY vexRT[Ch2]
#define LY vexRT[Ch3]
#define LX vexRT[Ch4]

float flyPwr,
	flyTarget,
	error,
	errorLast = 0,
	encNow,
	encLast = 0,
	timeNow,
	timeLast = 0,
	kP = .1,
	kI = .01,
	kD = .01,
	P,
	I = 0,
	D;

void setLDrive(int pwr) {
	motor[lDrive] = pwr;
}

void setRDrive(int pwr) {
	motor[rDrive] = pwr;
}

int arcL(int x, int y) {
	return y + x;
}

int arcR(int x, int y) {
	return y - x;
}

void setIntake(int pwr) {
	motor[roller] =
		motor[lift] =
		pwr;
}

float velCalc() {
	encNow = SensorValue[flyEnc];
	timeNow = nPgmTime;
	return (encNow - encLast) / (timeNow - timeLast);
	encLast = encNow;
	timeLast = timeNow;
}

task flyControl() {
	while(true) {
		encNow = SensorValue[flyEnc];
		timeNow = nPgmTime;
		error = flyTarget - velCalc();
		P = error * kP;
		I += error * kI;
		if(I > 127)
			I = 127;
		else if(I < 0)
			I = 0;
		D = kD * (error - errorLast) / (timeNow - timeLast);
		errorLast = error;
		encLast = encNow;
		timeLast = timeNow;
		flyPwr = P + I + D;
		if(flyPwr > 127)
			flyPwr = 127;
		else if(flyPwr < 0)
			flyPwr = 0;
		wait1Msec(20);
	}
}

void setFly(float pwr) {
	motor[lFly1] =
		motor[lFly2] =
		motor[lFly3] =
		motor[rFly1] =
		motor[rFly2] =
		motor[rFly3] =
		pwr;
}


task main() {
	startTask(flyControl);
	while(true) {
		setRDrive(arcR(RX, LY));
		setLDrive(arcL(RX, LY));
		setIntake(127*(vexRT[Btn6U]-vexRT[Btn6D]));
		setFly(flyPwr);
		wait1Msec(20);
	}
}
