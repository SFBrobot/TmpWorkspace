#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  flyEnc,         sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           intake,        tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           brWheel,       tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           frWheel,       tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port4,           blWheel,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port5,           flWheel,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port6,           brFly,         tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port7,           trFly,         tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           blFly,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           tlFly,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          lift,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "rkUtil003.h"

#include "rkLogic/dlatch001.h"

#include "rkControl/base002.h"
#include "rkControl/diff003.h"
#include "rkControl/kalman001.h"
#include "rkControl/tbh006.h"
#include "rkControl/tbhController002.h"

//#define RKCOMP_DEBUG

#define RKCOMP_DEBUG_MENU_COND vexRT[Btn8R]
#define RKCOMP_DEBUG_DISABLE_COND vexRT[Btn8U]
#define RKCOMP_DEBUG_AUTON_COND vexRT[Btn8L]
#define RKCOMP_DEBUG_DRIVER_COND vexRT[Btn8D]
#define RKCOMP_DEBUG_RESTART_COND vexRT[Btn6U]

#include "rkCompetition003a.h"

const float flyLRPwr = 825,
	flySRPwr = 550;

ADiff flyDiff, fly2Diff;
KFlt fly2Flt;
Tbh flyTbh;
TbhController flyCtl;

void startFlyTbh(bool doUseCtl) {
	resetDiff(&flyDiff, 0);
	resetDiff(&fly2Diff, 0);

	resetKFlt(&fly2Flt, 0, 1);

	if (doUseCtl) updateTbhController(&flyCtl, 0);
	else setTbhDoRun(&flyTbh, true);

	SensorValue[flyEnc] = 0;
}

void stopCtls() {
	setTbhDoRun(&flyTbh, false);

	stopCtlLoop();
}

void init() {
	initKFlt(&fly2Flt, 10);

	initTbh(&flyTbh, 5, .25, .15, 127, true);

	initTbhController(&flyCtl, &flyTbh, false);

	ctlLoopInterval = 50;
}

void updateCtl(float dt) {
	updateDiff(&flyDiff, SensorValue[flyEnc], dt);
	updateDiff(&fly2Diff, flyDiff.out, dt);

	updateKFlt(&fly2Flt, fly2Diff.out, dt);

	if (flyTbh.doUpdate)
		motor[brFly] = motor[trFly] =
			motor[blFly] = motor[tlFly] = updateTbh(&flyTbh, flyDiff.out, fly2Flt.out, dt);
}

task auton() { }

void endAuton() { }

task userOp() {
	startFlyTbh(true);
	startCtlLoop();

	bool flipDrive = false;

	word driveX, driveY,
		flyDir = 0;

	DLatch flipLatch, flyLRLatch, flySRLatch;

	resetDLatch(&flipLatch, 0);
	resetDLatch(&flyLRLatch, 0);
	resetDLatch(&flySRLatch, 0);

	while (true) {
		if (risingEdge(flipLatch, vexRT[Btn8D])
			flipDrive = !flipDrive;

		driveX = vexRT[ChLX];
		driveY = vexRT[ChLY];

		if (flipDrive) driveY = -driveY;

		arcade4(driveX, driveY, blWheel, flWheel, brWheel, frWheel);

		if (risingEdge(&flyLRLatch, vexRT[Btn5U]))
			flyDir = flyDir == 1 ? 0 : 1;

		if (risingEdge(&flySRLatch, vexRT[Btn5D]))
			flyDir = flyDir == 2 ? 0 : 2;

		switch(flyDir) {
			case 1: updateTbhController(&flyCtl, flyLRPwr); break;
			case 2: updateTbhController(&flyCtl, flySRPwr); break;
			default: updateTbhController(&flyCtl, 0); break;
		}

		motor[intake] = motor[lift] =
			joyDigi2(Btn6U, 127, Btn6D, -127);
	}
}

void endUserOp() {
	stopCtls();
}
