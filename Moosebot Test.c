#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  redLed,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  yellowLed,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  greenLed,       sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           lift,          tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           blWheel,       tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           flWheel,       tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port4,           brWheel,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port5,           frWheel,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port6,           trFly,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           tlFly,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           brFly,         tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port9,           blFly,         tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          intake,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define RKCOMP_LCD //Enable LCD stuff in rkCompetition

#include "rkCompetition002.h"
#include "rkUtil002.h"
#include "rkControl/base001.h"
#include "rkControl/tbh002.h"

float dLFlyEnc = 0,
	dRFlyEnc = 0;

task lcd() {
	string str;

	while (true) {
		if (bIfiRobotDisabled || bIfiAutonomousMode || (nLCDButtons & kButtonCenter)) {
			sprintf(str, "%6.2f // %-6.2f", nImmediateBatteryLevel / 1000., BackupBatteryLevel / 1000.);

			clearLCD();
			displayLCDCenteredString(0, "Battery:");
			displayLCDString(1, 0, str);
		}
		else {
			sprintf(str, "%6.2f -- %-6.2f", dLFlyEnc, dRFlyEnc);

			clearLCD();

			displayLCDCenteredString(0, "Ticks/sec:");
			displayLCDString(1, 0, str);

		}
		wait1Msec(25);
	}
}

void init() {
	bLCDBacklight = true;
	clearLCD();
}

long lFlyEnc = 0,
	rFlyEnc = 0,
	lastLFlyEnc = 0,
	lastRFlyEnc = 0;

void updateCtl(float dt) {
	lastLFlyEnc = lFlyEnc;
	lastRFlyEnc = rFlyEnc;

	lFlyEnc = getMotorEncoder(blFly);
	rFlyEnc = getMotorEncoder(brFly);

	dLFlyEnc = (lFlyEnc - lastLFlyEnc) / dt;
	dRFlyEnc = (rFlyEnc - lastRFlyEnc) / dt;
}

task auton() { }

void endAuton() { }

task userOp() {
	startCtlLoop();

	const word val = 127;

	while(true) {
		//motor[trFly] = motor[tlFly] =
		//	motor[brFly] = motor[blFly] =
		//	joyDigi1(Btn5U, 127);

		motor[blWheel] = joyDigi1(Btn5D, val);
		motor[brWheel] = joyDigi1(Btn6D, val);
		motor[flWheel] = joyDigi1(Btn5U, val);
		motor[frWheel] = joyDigi1(Btn6U, val);

		EndTimeSlice();
	}
}

void endUserOp() { }
